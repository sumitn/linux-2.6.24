/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/vm_area.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_sfuse.h"
#endif /* FISTGEN */
#include "fist.h"
#include "sfuse.h"

#ifdef NOT_NEEDED
#error this is the old mmap method from file.c
STATIC int
sfuse_mmap(file_t *file, vm_area_t *vma)
{
        int err = 0;
        file_t *lower_file = NULL;
        inode_t *inode;
        inode_t *lower_inode;
        vm_area_t *lower_vma = (vm_area_t *) 0xdeadc0de;

        print_entry_location();
        if (FILE_TO_PRIVATE(file) != NULL)
                lower_file = FILE_TO_LOWER(file);
        BUG_ON(!lower_file);
        inode = file->f_dentry->d_inode;
        lower_inode = INODE_TO_LOWER(inode);

        fist_dprint(6, "MMAP1: inode 0x%x, lower_inode 0x%x, inode->i_count %d, lower_inode->i_count %d\n",
                    (int) inode, (int) lower_inode, atomic_read(&inode->i_count), atomic_read(&lower_inode->i_count));

        if (!lower_file->f_op || !lower_file->f_op->mmap) {
                err = -ENODEV;
                goto out;
        }

        /*
         * Most of this code comes straight from generic_file_mmap
         * in mm/filemap.c.
         */
        if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {
                vma->vm_ops = &sfuse_shared_vmops;
        } else {
                vma->vm_ops = &sfuse_private_vmops;
        }
        if (!inode->i_sb || !S_ISREG(inode->i_mode)) {
                err = -EACCES;
                goto out;
        }
        if (!lower_inode->i_op || !lower_inode->i_mapping->a_ops->readpage) {
                err = -ENOEXEC;
                goto out;
        }
        UPDATE_ATIME(inode);

        /*
         * Now we do the lower stuff, but only for shared maps.
         */
        if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {
                lower_vma = KMALLOC(sizeof(vm_area_t), GFP_KERNEL);
                if (!lower_vma) {
                        printk("MMAP: Out of memory\n");
                        err = -ENOMEM;
                        goto out;
                }
                // ION, is this right?
                memcpy(lower_vma, vma, sizeof(vm_area_t));
                VMA_TO_LOWER(vma) = lower_vma;
                err = lower_file->f_op->mmap(lower_file, lower_vma);
                lower_vma->vm_file = lower_file;
                atomic_inc(&lower_file->f_count);
        }

        /*
         * XXX: do we need to insert_vm_struct and merge_segments as is
         * done in do_mmap()?
         */
out:
        fist_dprint(6, "MMAP2: inode 0x%x, lower_inode 0x%x, inode->i_count %d, lower_inode->i_count %d\n",
                    (int) inode, (int) lower_inode, atomic_read(&inode->i_count), atomic_read(&lower_inode->i_count));
#if 0
        if (!err) {
                inode->i_mmap = vma;
                lower_inode->i_mmap = lower_vma;
        }
#endif
        print_exit_status(err);
        return err;
}


STATIC void
sfuse_vm_open(vm_area_t *vma)
{
        vm_area_t *lower_vma, *lower_vma2;
        file_t *file;
        file_t *lower_file = NULL;

        print_entry_location();

        lower_vma = VMA_TO_LOWER(vma);
        file = vma->vm_file;
        if (FILE_TO_PRIVATE(file) != NULL)
                lower_file = FILE_TO_LOWER(file);
        BUG_ON(!lower_file);

        fist_dprint(6, "VM_OPEN: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));

        if (lower_vma->vm_ops->open)
                lower_vma->vm_ops->open(lower_vma);
        atomic_inc(&lower_file->f_count);

        /* we need to duplicate the private data */
        lower_vma2 = KMALLOC(sizeof(vm_area_t), GFP_KERNEL);
        if (!lower_vma2) {
                printk("VM_OPEN: Out of memory\n");
                goto out;
        }
        memcpy(lower_vma2, lower_vma, sizeof(vm_area_t));
        VMA_TO_LOWER(vma) = lower_vma2;

out:
        fist_dprint(6, "VM_OPEN2: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));
        print_exit_location();
}


STATIC void
sfuse_vm_close(vm_area_t *vma)
{
        vm_area_t *lower_vma;
        file_t *file;
        file_t *lower_file = NULL;

        print_entry_location();

        lower_vma = VMA_TO_LOWER(vma);
        file = vma->vm_file;
        if (FILE_TO_PRIVATE(file) != NULL)
                lower_file = FILE_TO_LOWER(file);
        BUG_ON(!lower_file);

        fist_dprint(6, "VM_CLOSE1: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));

        BUG_ON(!lower_vma);

        if (lower_vma->vm_ops->close)
                lower_vma->vm_ops->close(lower_vma);
        fput(lower_file);
        KFREE(lower_vma);
        VMA_TO_LOWER(vma) = NULL;

        fist_dprint(6, "VM_CLOSE2: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));
        print_exit_location();
}


STATIC void
sfuse_vm_shared_unmap(vm_area_t *vma, unsigned long start, size_t len)
{
        vm_area_t *lower_vma;

        print_entry_location();
        lower_vma = VMA_TO_LOWER(vma);
        file = vma->vm_file;
        if (FILE_TO_PRIVATE(file) != NULL)
                lower_file = FILE_TO_LOWER(file);
        BUG_ON(!lower_file);

        fist_dprint(6, "VM_S_UNMAP1: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));

        /*
         * call sync (filemap_sync) because the default filemap_unmap
         * calls it too.
         */
        filemap_sync(vma, start, len, MS_ASYNC);

        if (lower_vma->vm_ops->unmap)
                lower_vma->vm_ops->unmap(lower_vma, start, len);

        fist_dprint(6, "VM_S_UNMAP2: file 0x%x, lower_file 0x%x, file->f_count %d, lower_file->f_count %d\n",
                    (int) file, (int) lower_file,
                    (int) atomic_read(&file->f_count),
                    (int) atomic_read(&lower_file->f_count));
        print_exit_location();
}


/*
 * Shared mappings need to be able to do the right thing at
 * close/unmap/sync. They will also use the private file as
 * backing-store for swapping..
 */
struct vm_operations_struct sfuse_shared_vmops = {
        open:      sfuse_vm_open,
        close:     sfuse_vm_close,
        unmap:     sfuse_vm_shared_unmap,
        sync:      filemap_sync,
        nopage:    filemap_nopage,
        swapout:   filemap_swapout,
};


/*
 * Private mappings just need to be able to load in the map.
 *
 * (This is actually used for shared mappings as well, if we
 * know they can't ever get write permissions..)
 */
struct vm_operations_struct sfuse_private_vmops = {
        nopage:    filemap_nopage,
};
#endif /* NOT_NEEDED */

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
