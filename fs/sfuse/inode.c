/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/inode.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */

#ifdef FISTGEN
#include "fist_sfuse.h"
#endif /* FISTGEN */

#include "fist.h"
#include "sfuse.h"

//XXX: mickg: pagemap.h cannot be included for some arcane reason, so this hack.
//#define PAGE_CACHE_SHIFT	PAGE_SHIFT
//#define PAGE_CACHE_SIZE		PAGE_SIZE
//#define PAGE_CACHE_MASK		PAGE_MASK

/*
 * Common dentry functions for inclusion in the VFS
 * or in other stackable file systems.  Some of these
 * functions were in linux/fs/ C (VFS) files.
 *
 */

/*
 * Locking the parent is needed to:
 *  - serialize directory operations
 *  - make sure the parent doesn't change from
 *    under us in the middle of an operation.
 *
 * NOTE! Right now we'd rather use a "struct inode"
 * for this, but as I expect things to move toward
 * using dentries instead for most things it is
 * probably better to start with the conceptually
 * better interface of relying on a path of dentries.
 */
static inline struct dentry *sfuse_lock_parent(struct dentry *dentry) 
{
    struct dentry *dir = dget(dentry->d_parent);

    lock_inode(dir->d_inode);
    return dir;
}

static inline void unlock_dir(struct dentry *dir)
{
    unlock_inode(dir->d_inode);
    dput(dir);
}

int sfuse_create(inode_t *dir, struct dentry *dentry, int mode, 
			struct nameidata *nd)
{
    int err;
    struct dentry *lower_dentry;
    struct vfsmount *lower_mount;
    struct dentry *lower_dir_dentry;
    FIST_ND_DECLARATIONS;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);
    BUG_ON(!lower_dentry);
    fist_checkinode(dir, "sfuse_create");
    lower_mount = DENTRY_TO_LVFSMNT(dentry);

    lower_dir_dentry = sfuse_lock_parent(lower_dentry);
    err = PTR_ERR(lower_dir_dentry);
    if (IS_ERR(lower_dir_dentry))
	goto out;

    FIST_ND_SAVE_ARGS(dentry, lower_dentry, lower_mount);
    err = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, nd);
    FIST_ND_RESTORE_ARGS;
    /* XXX this could potentially return a negative lower_dentry! */
    if (err)
	goto out_lock;

    err = sfuse_interpose(lower_dentry, dentry, dir->i_sb, 0);
    if (err)
	goto out_lock;

    fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);


  out_lock:
    unlock_dir(lower_dir_dentry);
  out:
    fist_checkinode(dir, "post sfuse_create");
    print_exit_status(err);
    return err;
}


static struct dentry *sfuse_lookup(inode_t *dir,
	     struct dentry *dentry,
	     struct nameidata* nd_unused_in_this_fxn /* XXX: fix code if ever used */ )
{
    int err = 0;
    struct dentry *lower_dir_dentry;
    struct dentry *lower_dentry = NULL;
    struct vfsmount *lower_mount;
    const char *name;
    vnode_t *this_vnode;
    struct dentry *this_dir;
    unsigned int namelen;

    print_entry_location();
    lower_dir_dentry = sfuse_lower_dentry(dentry->d_parent);	/* CPW: Moved below print_entry_location */
    name = dentry->d_name.name;
    namelen = dentry->d_name.len;
    fist_checkinode(dir, "sfuse_lookup");

    this_vnode = dir;
    this_dir = lower_dir_dentry;

    fist_print_dentry("sfuse_lookup IN", dentry);
    fist_print_dentry("sfuse_lookup: dentry->d_parent IN", dentry->d_parent);
    fist_print_dentry("sfuse_lookup: lower_dir_dentry IN", lower_dir_dentry);
    fist_print_inode("sfuse_lookup: dir IN", dir);

    if (lower_dir_dentry->d_inode)
	fist_print_inode("sfuse_lookup: lower_dir_dentry->d_inode",
			 lower_dir_dentry->d_inode);

    /* must initialize dentry operations */
    dentry->d_op = &sfuse_dops;

    ;

    /* increase refcount of base dentry (lookup_one[_len] will decrement) */
    // THIS IS RIGHT! (don't "fix" it)
    // NO THIS IS WRONG IN 2.3.99-pre6. lookup_one[_len] will NOT decrement
    // dget(lower_dir_dentry);

    lock_inode(lower_dir_dentry->d_inode);
    /* will allocate a new lower dentry if needed */
    lower_dentry = lookup_one_len(name, lower_dir_dentry, namelen);
    unlock_inode(lower_dir_dentry->d_inode);
    /* XXX: This needs to change to something intelligent with follow_down. */
    lower_mount = mntget(DENTRY_TO_LVFSMNT(dentry->d_parent));

    if (IS_ERR(lower_dentry)) {
	/*
	 * this produces an unusual dentry: one that has neither an
	 * inode, nor a private structure attached to it. All cleanup
	 * methods (d_delete, d_release, etc) must be prepared to deal
	 * with such dentries. Ion 09/29/2001
	 */
	printk("ERR from lower_dentry!!!\n");
	err = PTR_ERR(lower_dentry);
	goto out;
    }

    ;

    /* update parent directory's atime */
    fist_copy_attr_atime(dir, lower_dir_dentry->d_inode);
    /* link the upper and lower dentries */
    DENTRY_TO_PRIVATE_SM(dentry) = (struct sfuse_dentry_info *) KMALLOC(sizeof(struct sfuse_dentry_info), GFP_KERNEL);
    if (!DENTRY_TO_PRIVATE(dentry)) {
	err = -ENOMEM;
	goto out_dput;
    }
    DENTRY_TO_PRIVATE(dentry)->wdi_dentry = lower_dentry;
    DENTRY_TO_PRIVATE(dentry)->wdi_mnt = lower_mount;


    /* lookup is special: it needs to handle negative dentries */
    if (!lower_dentry->d_inode) {
	d_add(dentry, NULL);
	fist_print_dentry("sfuse_lookup OUT lower_dentry", lower_dentry);
	goto out;
    }

    fist_dprint(6, "lookup \"%s\" -> inode %lu\n", name, lower_dentry->d_inode->i_ino);
    err = sfuse_interpose(lower_dentry, dentry, dir->i_sb, 1);
    if (err)
	goto out_free;

    fist_checkinode(dentry->d_inode, "sfuse_lookup OUT: dentry->d_inode:");
    fist_checkinode(dir, "sfuse_lookup OUT: dir");

    fist_print_dentry("sfuse_lookup OUT lower_dentry", lower_dentry);
    fist_print_inode("sfuse_lookup OUT lower_inode", lower_dentry->d_inode);


    /* All is well */
    goto out;

  out_free:
    d_drop(dentry);		/* so that our bad dentry will get destroyed */


    KFREE(DENTRY_TO_PRIVATE(dentry));
    DENTRY_TO_PRIVATE_SM(dentry) = NULL;	/* be safe */

  out_dput:
    if (lower_dentry)
	dput(lower_dentry);

  out:
    fist_print_dentry("sfuse_lookup OUT", dentry);
    print_exit_status(err);
    return ERR_PTR(err);
}


STATIC int
sfuse_link(struct dentry *old_dentry, inode_t *dir, struct dentry *new_dentry)
{
    int err;
    struct dentry *lower_old_dentry;
    struct dentry *lower_new_dentry;
    struct dentry *lower_dir_dentry;

    print_entry_location();
    lower_old_dentry = sfuse_lower_dentry(old_dentry);	/* CPW: Moved below print_entry_location */
    lower_new_dentry = sfuse_lower_dentry(new_dentry);

    fist_checkinode(dir, "sfuse_link-dir");
    fist_checkinode(old_dentry->d_inode, "sfuse_link-oldinode");

    dget(lower_old_dentry);
    dget(lower_new_dentry);
    lower_dir_dentry = sfuse_lock_parent(lower_new_dentry);


    err = vfs_link(lower_old_dentry,
		   lower_dir_dentry->d_inode,
		   lower_new_dentry);
    if (err || !lower_new_dentry->d_inode)
	goto out_lock;

    err = sfuse_interpose(lower_new_dentry, new_dentry, dir->i_sb, 0);
    if (err)
	goto out_lock;

    fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
    /* propagate number of hard-links */
    old_dentry->d_inode->i_nlink = INODE_TO_LOWER(old_dentry->d_inode)->i_nlink;

  out_lock:
    unlock_dir(lower_dir_dentry);
    dput(lower_new_dentry);
    dput(lower_old_dentry);
    if (!new_dentry->d_inode)
	d_drop(new_dentry);

    print_exit_status(err);
    return err;
}


STATIC int
sfuse_unlink(inode_t *dir, struct dentry *dentry)
{
    int err = 0;
    inode_t *lower_dir;
    struct dentry *lower_dentry;
    struct dentry *lower_dir_dentry;

    print_entry_location();

    lower_dir = INODE_TO_LOWER(dir); /* CPW: Moved below print_entry_location */
    lower_dentry = sfuse_lower_dentry(dentry);

    BUG_ON(!lower_dentry);
    fist_checkinode(dir, "sfuse_unlink-dir");

    dget(dentry);
    lower_dir_dentry = sfuse_lock_parent(lower_dentry);


    /* avoid destroying the lower inode if the file is in use */
    dget(lower_dentry);
    err = vfs_unlink(lower_dir, lower_dentry);
    dput(lower_dentry);

    if (!err)			  /* vfs_unlink does that */
	d_delete(lower_dentry);

    fist_copy_attr_times(dir, lower_dir);
    /* propagate number of hard-links */
    dentry->d_inode->i_nlink = INODE_TO_LOWER(dentry->d_inode)->i_nlink;
    fist_copy_attr_ctime(dentry->d_inode, dir);

    unlock_dir(lower_dir_dentry);

    /*
     * call d_drop so the system "forgets" about us
     */
    if (!err) {
	d_drop(dentry);
    }

    dput(dentry);

    fist_checkinode(dir, "post sfuse_unlink-dir");
    print_exit_status(err);
    return err;
}


STATIC int
sfuse_symlink(inode_t *dir, struct dentry *dentry, const char *symname)
{
    int err;
    struct dentry *lower_dentry;
    struct dentry *lower_dir_dentry;
    umode_t	mode;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
    fist_checkinode(dir, "sfuse_symlink-dir");

    dget(lower_dentry);
    lower_dir_dentry = sfuse_lock_parent(lower_dentry);

    mode = S_IALLUGO;

/* In 2.6.7 vfs_symlink() has a fourth argument which is the symlink's mode */
/* The Friendly folk's at Red Hat decided that would be a good idea for 2.6.6 in Fedora Core.  */
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)) || defined(FEDORACORE2)
    err = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry, symname, mode);
# else /* kernel before 2.6.7 and not Fedora Core 2 */
    err = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry, symname);
# endif /* kernel before 2.6.7 and not Fedora Core 2 */


    if (err || !lower_dentry->d_inode)
	goto out_lock;
    err = sfuse_interpose(lower_dentry, dentry, dir->i_sb, 0);
    if (err)
	goto out_lock;

    fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
    fist_checkinode(dir, "post sfuse_symlink-dir");

  out_lock:
    unlock_dir(lower_dir_dentry);
    dput(lower_dentry);
    if (!dentry->d_inode)
	d_drop(dentry);

    print_exit_status(err);
    return err;
}


STATIC int
sfuse_mkdir(inode_t *dir, struct dentry *dentry, int mode)
{
    int err;
    struct dentry *lower_dentry;
    struct dentry *lower_dir_dentry;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
    fist_checkinode(dir, "sfuse_mkdir-dir");

    lower_dir_dentry = sfuse_lock_parent(lower_dentry);

    err = vfs_mkdir(lower_dir_dentry->d_inode,
		    lower_dentry,
		    mode);
    if (err || !lower_dentry->d_inode)
	goto out;

    err = sfuse_interpose(lower_dentry, dentry, dir->i_sb, 0);
    if (err)
	goto out;

    fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
    /* update number of links on parent directory */
    dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;

    fist_checkinode(dir, "post sfuse_mkdir-dir");

  out:
    unlock_dir(lower_dir_dentry);
    if (!dentry->d_inode)
	d_drop(dentry);

    print_exit_status(err);
    return err;
}


STATIC int
sfuse_rmdir(inode_t *dir, struct dentry *dentry)
{
    int err = 0;
    struct dentry *lower_dentry;
    struct dentry *lower_dir_dentry;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
    fist_checkinode(dir, "sfuse_rmdir-dir");

    dget(dentry);
    lower_dir_dentry = sfuse_lock_parent(lower_dentry);

    /* avoid destroying the lower inode if the file is in use */
    dget(lower_dentry);
    err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
    dput(lower_dentry);

    if (!err)			  /* vfs_rmdir does that */
	d_delete(lower_dentry);

    fist_copy_attr_times(dir, lower_dir_dentry->d_inode);
    /* copy the nlink count for our dentry and our parent's dentry */
    dir->i_nlink =  lower_dir_dentry->d_inode->i_nlink;

    unlock_dir(lower_dir_dentry);

    /*
     * call d_drop so the system "forgets" about us
     */
    if (!err)
	d_drop(dentry);

    dput(dentry);

    print_exit_status(err);
    return err;
}


STATIC int
sfuse_mknod(inode_t *dir, struct dentry *dentry, int mode, dev_t dev)
{
    int err;
    struct dentry *lower_dentry;
    struct dentry *lower_dir_dentry;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
    fist_checkinode(dir, "sfuse_mknod-dir");

    lower_dir_dentry = sfuse_lock_parent(lower_dentry);

    err = vfs_mknod(lower_dir_dentry->d_inode,
		    lower_dentry,
		    mode,
		    dev);
    if (err || !lower_dentry->d_inode)
	goto out;

    err = sfuse_interpose(lower_dentry, dentry, dir->i_sb, 0);
    if (err)
	goto out;
    fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);

  out:
    unlock_dir(lower_dir_dentry);
    if (!dentry->d_inode)
	d_drop(dentry);

    fist_checkinode(dir, "post sfuse_mknod-dir");
    print_exit_status(err);
    return err;
}


STATIC int
sfuse_rename(inode_t *old_dir, struct dentry *old_dentry,
	     inode_t *new_dir, struct dentry *new_dentry)
{
    int err;
    struct dentry *lower_old_dentry;
    struct dentry *lower_new_dentry;
    struct dentry *lower_old_dir_dentry;
    struct dentry *lower_new_dir_dentry;

    print_entry_location();

    lower_old_dentry = sfuse_lower_dentry(old_dentry);/* CPW: Moved below print_entry_location */
    lower_new_dentry = sfuse_lower_dentry(new_dentry);

    fist_checkinode(old_dir, "sfuse_rename-old_dir");
    fist_checkinode(new_dir, "sfuse_rename-new_dir");

    dget(lower_old_dentry);
    dget(lower_new_dentry);
    lower_old_dir_dentry = dget_parent(lower_old_dentry);
    lower_new_dir_dentry = dget_parent(lower_new_dentry);
    lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);


    err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
		     lower_new_dir_dentry->d_inode, lower_new_dentry);
    if (err)
	goto out_lock;

    fist_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);
    if (new_dir != old_dir)
	fist_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);

  out_lock:
    // unlock_rename will dput the new/old parent dentries whose refcnts
    // were incremented via dget_parent above.
    dput(lower_new_dentry);
    dput(lower_old_dentry);
    unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);

    fist_checkinode(new_dir, "post sfuse_rename-new_dir");
    print_exit_status(err);
    return err;
}


STATIC int
sfuse_readlink(struct dentry *dentry, char *buf, int bufsiz)
{
    int err;
    struct dentry *lower_dentry;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);/* CPW: Moved below print_entry_location */
    fist_print_dentry("sfuse_readlink IN", dentry);

    if (!lower_dentry->d_inode->i_op ||
	!lower_dentry->d_inode->i_op->readlink) {
	err = -EINVAL;
	goto out;
    }

    err = lower_dentry->d_inode->i_op->readlink(lower_dentry,
						buf,
						bufsiz);
    if (err > 0)
	fist_copy_attr_atime(dentry->d_inode, lower_dentry->d_inode);

  out:
    print_exit_status(err);
    return err;
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
STATIC int
sfuse_follow_link(struct dentry *dentry, struct nameidata *nd)
#else /* 2.6.13 or newer */
    STATIC void *
    sfuse_follow_link(struct dentry *dentry, struct nameidata *nd)
#endif /* 2.6.13 or newer */
{
    char *buf;
    int len = PAGE_SIZE, err;
    mm_segment_t old_fs;

    print_entry_location();

    /* buf is allocated here, and freed when VFS calls 
       our put_link method */
    err = -ENOMEM;
    buf = KMALLOC(len, GFP_KERNEL);
    if (!buf)
	goto out;

    old_fs = get_fs();
    set_fs(KERNEL_DS);
    err = dentry->d_inode->i_op->readlink(dentry, buf, len);
    set_fs(old_fs);
    if (err < 0)
	goto out_free;

    buf[err] = 0;	// terminate the buffer -- XXX still needed?
    err = 0;
    nd_set_link(nd,buf);
    goto out;

  out_free:
    KFREE(buf);
  out:
#if 0
    if (err < 0) {
	dput(nd->dentry);
	printk("EZK follow_link() mnt_cnt %d\n", atomic_read(&nd->mnt->mnt_count));
	mntput(nd->mnt);
    }
#endif

    print_exit_status(err);
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
    return err;
#else /* 2.6.13 or newer */
    return ERR_PTR(err);
#endif /* 2.6.13 or newer */
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
void
sfuse_put_link(struct dentry *dentry, struct nameidata *nd)
#else /* 2.6.13 or newer */
    void
    sfuse_put_link(struct dentry *dentry, struct nameidata *nd, void* unused)
#endif /* 2.6.13 or newer */
{
    print_entry_location();

    KFREE(nd_get_link(nd));

    print_exit_location();
}

/* We call only the lower-level permission so that file systems with ACLs
 * or more complex permission models work correctly.  This results in
 * O(n^2) calls to permission with n stacked file systems, because each
 * vfs_foo function first calls permission for the top layer, which in
 * turn makes n calls, then calls vfs_foo on the next layer, which will
 * make n calls, etc.
 *
 * An alternative would be to punt permission checking entirely to the
 * lower-level file system, but then we would need to check that we aren't
 * performing any operations without appropriate permissions checking.
 */
static int sfuse_permission(inode_t *inode, int mask, struct nameidata* nd)
{
    inode_t *lower_inode = NULL;
    int err;
    struct dentry *lower_dentry = NULL;
    struct vfsmount *lower_mount = NULL;
    FIST_ND_DECLARATIONS;

    print_entry_location();
    lower_inode = INODE_TO_LOWER(inode);

    if(nd)
    {
	BUG_ON(!nd->dentry);	/* needed to find lower_dentry */
	lower_dentry = sfuse_lower_dentry(nd->dentry);
	lower_mount = DENTRY_TO_LVFSMNT(nd->dentry);
	BUG_ON(!SUPERBLOCK_TO_PRIVATE(nd->dentry->d_sb)); 
             /* needed in FIST_ND_SAVE_ARGS macro */
	FIST_ND_SAVE_ARGS(nd->dentry, lower_dentry, lower_mount);
    }

    err = permission(lower_inode, mask, nd);

    if(nd)
    {
	FIST_ND_RESTORE_ARGS;
    }

    print_exit_status(err);
    return err;
}

static int sfuse_setattr(struct dentry *dentry, struct iattr *ia)
{
    int err = 0;
    struct dentry *lower_dentry;
    inode_t *inode;
    inode_t *lower_inode;

    print_entry_location();
    lower_dentry = sfuse_lower_dentry(dentry);
    inode = dentry->d_inode;
    lower_inode = INODE_TO_LOWER(inode);
    fist_checkinode(inode, "sfuse_setattr");



    err = notify_change(lower_dentry, ia);

#if defined(FIST_FILTER_DATA) || defined(FIST_FILTER_SCA)
  out:
#endif /* FIST_FILTER_DATA || FIST_FILTER_SCA */
    /*
     * The lower file system might has changed the attributes, even if
     * notify_change above resulted in an error(!)  so we copy the
     * lower_inode's attributes (and a few more) to our inode.
     */
    fist_copy_attr_all(inode, lower_inode);

    fist_checkinode(inode, "post sfuse_setattr");
    print_exit_status(err);
    return err;
}


#ifdef NOT_USED_YET
STATIC int
sfuse_getattr(struct dentry *dentry, struct iattr *ia)
{
    return -ENOSYS;
}
#endif /* NOT_USED_YET */

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC ssize_t
sfuse_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
{
    struct dentry *lower_dentry = NULL;
    int err = -ENOTSUPP;
    /* Define these anyway so we don't need as much ifdef'ed code. */
    char *encoded_name = NULL;
    char *encoded_value = NULL;

    print_entry_location();

    lower_dentry = DENTRY_TO_LOWER(dentry);

    BUG_ON(!lower_dentry);
    BUG_ON(!lower_dentry->d_inode);
    BUG_ON(!lower_dentry->d_inode->i_op);

    fist_dprint(18, "getxattr: name=\"%s\", value %d bytes\n", name, size);

    if (lower_dentry->d_inode->i_op->getxattr) {
	encoded_name = (char *)name;

	encoded_value = (char *)value;


	lock_inode(lower_dentry->d_inode);
	/* lock_kernel() already done by caller. */
	err = lower_dentry->d_inode->i_op->getxattr(lower_dentry, encoded_name, encoded_value, size);
	/* unlock_kernel() will be done by caller. */
	unlock_inode(lower_dentry->d_inode);

    }

    print_exit_status(err);
    return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC int //XXX: was made consistent
sfuse_setxattr(struct dentry *dentry, const char *name, const void *value,size_t size, int flags)

{
    struct dentry *lower_dentry = NULL;
    int err = -ENOTSUPP;
    /* Define these anyway, so we don't have as much ifdef'ed code. */
    char *encoded_value = NULL;
    char *encoded_name = NULL;

    print_entry_location();

    lower_dentry = DENTRY_TO_LOWER(dentry);

    BUG_ON(!lower_dentry);
    BUG_ON(!lower_dentry->d_inode);
    BUG_ON(!lower_dentry->d_inode->i_op);

    fist_dprint(18, "setxattr: name=\"%s\", value %d bytes, flags=%x\n", name, size, flags);

    if (lower_dentry->d_inode->i_op->setxattr) {
	encoded_name = (char *)name;

	encoded_value = (char *)value;

	lock_inode(lower_dentry->d_inode);
	/* lock_kernel() already done by caller. */
	err = lower_dentry->d_inode->i_op->setxattr(lower_dentry, encoded_name, encoded_value, size, flags);
	/* unlock_kernel() will be done by caller. */
	unlock_inode(lower_dentry->d_inode);
    }

    print_exit_status(err);
    return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC int
sfuse_removexattr(struct dentry *dentry, const char *name)
{
    struct dentry *lower_dentry = NULL;
    int err = -ENOTSUPP;
    char *encoded_name;
    print_entry_location();

    lower_dentry = DENTRY_TO_LOWER(dentry);

    BUG_ON(!lower_dentry);
    BUG_ON(!lower_dentry->d_inode);
    BUG_ON(!lower_dentry->d_inode->i_op);

    fist_dprint(18, "removexattr: name=\"%s\"\n", name);

    if (lower_dentry->d_inode->i_op->removexattr) {
	encoded_name = (char *)name;

	lock_inode(lower_dentry->d_inode);
	/* lock_kernel() already done by caller. */
	err = lower_dentry->d_inode->i_op->removexattr(lower_dentry, encoded_name);
	/* unlock_kernel() will be done by caller. */
	unlock_inode(lower_dentry->d_inode);
    }

    print_exit_status(err);
    return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC ssize_t
sfuse_listxattr(struct dentry *dentry, char *list, size_t size)
{
    struct dentry *lower_dentry = NULL;
    int err = -ENOTSUPP;
    char *encoded_list = NULL;

    print_entry_location();

    lower_dentry = DENTRY_TO_LOWER(dentry);

    BUG_ON(!lower_dentry);
    BUG_ON(!lower_dentry->d_inode);
    BUG_ON(!lower_dentry->d_inode->i_op);

    if (lower_dentry->d_inode->i_op->listxattr) {
	encoded_list = list;
	lock_inode(lower_dentry->d_inode);
	/* lock_kernel() already done by caller. */
	err = lower_dentry->d_inode->i_op->listxattr(lower_dentry, encoded_list, size);
	/* unlock_kernel() will be done by caller. */
	unlock_inode(lower_dentry->d_inode);
    }

    print_exit_status(err);
    return err;
}

struct inode_operations sfuse_symlink_iops =
{
  readlink:   sfuse_readlink,
  follow_link: sfuse_follow_link,
  put_link: sfuse_put_link,
  permission: sfuse_permission,
  //revalidate: sfuse_inode_revalidate,
  setattr:    sfuse_setattr,
#if 0
  // XXX: off, b/c the VFS doesn't call getattr yet
  getattr:    sfuse_getattr,
#endif

  setxattr:   sfuse_setxattr,
  getxattr:   sfuse_getxattr,
  listxattr:  sfuse_listxattr,
  removexattr: sfuse_removexattr
};

struct inode_operations sfuse_dir_iops =
{
  create: sfuse_create,
  lookup: sfuse_lookup,
  link:   sfuse_link,
  unlink: sfuse_unlink,
  symlink:    sfuse_symlink,
  mkdir:  sfuse_mkdir,
  rmdir:  sfuse_rmdir,
  mknod:  sfuse_mknod,
  rename: sfuse_rename,
  /* no readlink/follow_link for non-symlinks */
  // off because we have setattr
  //    truncate:	sfuse_truncate,
  permission: sfuse_permission,
  //revalidate: sfuse_inode_revalidate,
  setattr:    sfuse_setattr,
#if 0
  // XXX: off, b/c the VFS doesn't call getattr yet
  getattr:    sfuse_getattr,
#endif
  setxattr:   sfuse_setxattr,
  getxattr:   sfuse_getxattr,
  listxattr:  sfuse_listxattr,
  removexattr: sfuse_removexattr
};

struct inode_operations sfuse_main_iops =
{
  permission: sfuse_permission,
  //revalidate: sfuse_inode_revalidate, //XXX: Revalidate is GONE
  setattr:    sfuse_setattr,
#if 0
  // XXX: off, b/c the VFS doesn't call getattr yet
  getattr:    sfuse_getattr,
#endif
  setxattr:   sfuse_setxattr,
  getxattr:   sfuse_getxattr,
  listxattr:  sfuse_listxattr,
  removexattr: sfuse_removexattr
};

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
